#!/usr/bin/env bash
# Run shellcheck on shell-scripts before commit
set -Eeuo pipefail
trap 'echo "${BASH_SOURCE[0]}: line $LINENO: $BASH_COMMAND: exitcode $?"' ERR
# shellcheck source-path=SCRIPTDIR
source "$(dirname "${BASH_SOURCE[0]}")/../__common"

if [[ -n "${IGNORE_SHELLCHECK:-}" ]]; then
    warn "IGNORE_SHELLCHECK enabled; skipping checks"
    exit 0
fi

if ! command -v shellcheck &>/dev/null ; then
    warn "shellcheck not installed; skipping checks"
    exit 0
fi

is_shell_script() {
    local file="$1"

    # Check if filename matches shell script patterns:
    #   ^[^.]+$ - files with no dots (no extension)
    #   \.sh$   - files ending with .sh
    local basename
    basename="$(basename "$file")"
    if ! [[ "$basename" =~ (^[^.]+$|\.sh$) ]]; then
        return 1
    fi

    # Skip binary files
    if ! file --mime-encoding "$file" | rg -q 'us-ascii|utf-8|iso-8859'; then
        trace "Skipping $file (binary file)"
        return 1
    fi

    # Ignore files that don't have shell-script shebang: "#!...sh"
    if ! awk 'NR==1 && /^#!/ && /sh$/{exit 0} {exit 1}' "$file" ; then
        trace "Skipping $file (not shell script)"
        return 1
    fi

    return 0
}

get_arguments_or_staged_files ".*" "$@"

# Only shellcheck the shell scripts
SHELL_FILES=()
for file in "${FILES[@]}"; do
    # shellcheck disable=SC2310 # set -e will be disabled
    if is_shell_script "$file" ; then
        SHELL_FILES+=("$file")
    fi
done

# Scan all the files
if [[ "${#SHELL_FILES[@]}" -ne 0 ]]; then
    shellcheck "${SHELL_FILES[@]}"
fi
