#!/usr/bin/env bash
set -Eeuo pipefail
trap 'echo "${BASH_SOURCE[0]}: line $LINENO: $BASH_COMMAND: exitcode $?"' ERR

# Avoid recursion
[[ -z "${RECURSE_HOOK:-}" ]] || exit
export RECURSE_HOOK=1

[[ "${VERBOSE:-0}" =~ ^[0-9]+$ ]] && VERBOSE="${VERBOSE:-0}" || VERBOSE=1
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SCRIPT_NAME="$(basename "${BASH_SOURCE[0]}")"
GIT_DIR="$(git rev-parse --absolute-git-dir)"

RED='\033[0;31m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
GRAY='\033[90m'
NC='\033[0m' # No Color

if [[ "$SCRIPT_NAME" =~ "^__" ]]; then
    # Someone is trying to execute the __hook-template?!?
    echo >&2 "ERROR: something is wrong in the template expansion"
    exit 1
fi

PARALLEL_JOBS="${SV_HOOK_JOBS:-$(getconf _NPROCESSORS_ONLN 2>/dev/null || true)}"
if [[ -z "$PARALLEL_JOBS" || "$PARALLEL_JOBS" -lt 1 ]]; then
    PARALLEL_JOBS=$(sysctl -n hw.ncpu 2>/dev/null || true)
fi
if [[ -z "$PARALLEL_JOBS" || "$PARALLEL_JOBS" -lt 1 ]]; then
    PARALLEL_JOBS=4
fi

HOOK_PIDS=()
HOOK_NAMES=()
HOOK_OUTPUTS=()
RESULTS_DIR=$(mktemp -d)
trap 'rm -rf "$RESULTS_DIR"' EXIT

call_hook() {
    local hookName="$1"
    shift
    local shortName="${hookName/$HOME/\~}"

    # `[[ -x "$hookName" ]]` returns true on OSX when the file has ACLS with execute
    # permission, even though the file is `chmod -x`, so use `command -v` instead
    if ! command -v "$hookName" &>/dev/null ; then
        [[ "$VERBOSE" -lt 1 ]] || echo -e >&2 "${YELLOW}$SCRIPT_NAME: skip $shortName${NC}"
        return
    fi

    [[ "$VERBOSE" -lt 2 ]] || echo -e >&2 "${GRAY}$SCRIPT_NAME: queue $shortName${NC}"
    wait_for_slot
    local id
    id=$(printf "%04d" "${#HOOK_PIDS[@]}")
    local output_file="$RESULTS_DIR/$id.output"
    (
        set +e
        "$hookName" "$@"
    ) >"$output_file" 2>&1 &
    HOOK_PIDS+=("$!")
    HOOK_NAMES+=("$shortName")
    HOOK_OUTPUTS+=("$output_file")
}

wait_for_slot() {
    while :; do
        local running=0
        local pid
        for pid in "${HOOK_PIDS[@]-}"; do
            if kill -0 "$pid" 2>/dev/null; then
                ((running++)) || true
            fi
        done
        if [[ "$running" -lt "$PARALLEL_JOBS" ]]; then
            break
        fi
        sleep 0.05
    done
}

collect_results() {
    if [[ "${#HOOK_PIDS[@]}" -eq 0 ]]; then
        return
    fi

    set +e
    local i pid status shortName exit_code output_file
    exit_code=0
    for i in "${!HOOK_PIDS[@]}"; do
        pid="${HOOK_PIDS[$i]}"
        shortName="${HOOK_NAMES[$i]}"
        output_file="${HOOK_OUTPUTS[$i]}"
        if wait "$pid" 2>/dev/null; then
            status=0
        else
            status=$?
        fi
        [[ "$VERBOSE" -lt 1 ]] || echo -e >&2 "${GREEN}$SCRIPT_NAME: called $shortName${NC}"
        if [[ -f "$output_file" ]]; then
            cat "$output_file"
        fi
        if [[ "$status" != "0" ]]; then
            echo -e >&2 "${RED}$SCRIPT_NAME: $shortName failed ($status)${NC}"
            if [[ "$exit_code" -eq 0 ]]; then
                exit_code="$status"
            fi
        fi
    done
    set -e

    if [[ "$exit_code" -ne 0 ]]; then
        echo -e >&2 "${RED}$SCRIPT_NAME: commit failed${NC}"
        exit "$exit_code"
    fi
}

GLOBAL_HOOK_DIR="$SCRIPT_DIR/$SCRIPT_NAME.d"
if [[ -d "$GLOBAL_HOOK_DIR" ]]; then
    while IFS= read -r -d '' globalHook; do
        call_hook "$globalHook" "$@"
    done < <(find "$GLOBAL_HOOK_DIR" -type f -print0 | sort -z || true)
fi

REPO_HOOK_DIR="$GIT_DIR/hooks/$SCRIPT_NAME.d"
if [[ -d "$REPO_HOOK_DIR" ]]; then
    while IFS= read -r -d '' repoHook; do
        call_hook "$repoHook" "$@"
    done < <(find "$REPO_HOOK_DIR" -type f -print0 | sort -z || true)
fi

baseHook="$GIT_DIR/hooks/$SCRIPT_NAME"
if [[ -x "$baseHook" ]]; then
    call_hook "$baseHook" "$@"
fi

collect_results
